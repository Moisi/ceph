// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
// vim: ts=8 sw=2 smarttab ft=cpp

/**
 * @file rgw_handoff.cc
 * @author Andr√© Lucas (andre.lucas@storageos.com)
 * @brief 'Handoff' S3 authentication engine.
 * @version 0.1
 * @date 2023-07-04
 */

/* References are to the AWS Signature Version 4 documentation:
 *   https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html
 */

#include "rgw_handoff.h"

// We need the impl so we can call HandoffHelperImpl's methods and know the
// size of the object.
#include "rgw_handoff_impl.h"

#include <boost/algorithm/string.hpp>
#include <cstring>
#include <fmt/format.h>
#include <iostream>
#include <optional>
#include <string>
#include <string_view>

#include <time.h>

#include "include/ceph_assert.h"

#include "common/dout.h"
#include "rgw/rgw_http_client_curl.h"

#define dout_subsys ceph_subsys_rgw

namespace ba = boost::algorithm;

namespace rgw {

// This has to be here, in a .cc file where we know the size of
// HandoffHelperImpl. It can't be in the header file. See
// https://www.fluentcpp.com/2017/09/22/make-pimpl-using-unique_ptr/ .
HandoffHelper::HandoffHelper()
    : impl_ {
      std::make_unique<HandoffHelperImpl>()
    }
{
}

// This has to be here, in a .cc file where we know the size of
// HandoffHelperImpl. It can't be in the header file. See
// https://www.fluentcpp.com/2017/09/22/make-pimpl-using-unique_ptr/ .
HandoffHelper::~HandoffHelper() { }

int HandoffHelper::init(CephContext* const cct, rgw::sal::Store* store)
{
  ldout(cct, 20) << "HandoffHelper::init" << dendl;
  return impl_->init(cct, store);
};

HandoffAuthResult HandoffHelper::auth(const DoutPrefixProvider* dpp,
    const std::string_view& session_token,
    const std::string_view& access_key_id,
    const std::string_view& string_to_sign,
    const std::string_view& signature,
    const req_state* const s,
    optional_yield y)
{
  return impl_->auth(dpp, session_token, access_key_id, string_to_sign, signature, s, y);
};

/**
 * @brief Construct a new EAKParameters::EAKParameters object from a request.
 *
 * Given a request, read the parameters required to perform an EAK to the
 * Authenticator.
 *
 * The HTTP method, the bucket name, and optionally the object key name will
 * be extracted from the HTTP request parameters.
 *
 * In practice this amounts to an early invocation of parts of
 * RGWHandler_Lib::init_from_header(), where we need some of this information
 * in order to properly authenticate the request from an EAK-aware service.
 *
 * Only create this object when it's necessary to do so, namely before
 * attempting an EAK authentication. Doing work on an unauthenticated request
 * is in general a bad idea and risks introducing potential security problems.
 * For example, we've done nothing to validate the bucket and object key names
 * yet, though they will at least have been URL decoded.
 *
 * @param dpp DoutPrefixProvider.
 * @param s The request (const).
 */
EAKParameters::EAKParameters(const DoutPrefixProvider* dpp, const req_state* s) noexcept
{
  valid_ = false;

  if (s == nullptr) {
    ldpp_dout(dpp, 0) << "Handoff: invalid request pointer" << dendl;
    return;
  }

  // Method should be set in the request.
  if (!s->info.method || *(s->info.method) == 0) {
    ldpp_dout(dpp, 0) << "Handoff: Invalid request method for EAK" << dendl;
    return;
  }
  method_ = s->info.method;

  std::string req;
  std::string first;
  const char* req_name = s->relative_uri.c_str();

  ldpp_dout(dpp, 20) << "EAKParameters: req_name='" << req_name << "'" << dendl;

  // We expect the request portion including parameters, starting with the
  // leading slash. If it's not, we need to abort as the request is malformed.
  if (*req_name != '/') {
    ldpp_dout(dpp, 0) << "Handoff: Invalid relative_uri string for EAK" << dendl;
    return;
  }
  req_name++;

  // An empty request portion isn't useful to EAK, but is valid in general
  // non-EAK use - it's generated by e.g. 's3cmd ls'. However, we should only
  // be invoking EAKParameters in EAK mode, and we don't have a bucket or a
  // key, so we fail.
  if (*req_name == 0) {
    ldpp_dout(dpp, 0) << "Handoff: Insufficient parameters for EAK" << dendl;
    return;
  }

  // We're relying on the first parameter being the bucket name, even if the
  // original URL is of the form http://bucket.host.name/objectkey (as is
  // preferred by s3cmd).
  //
  // This canonicalisation step is performed by RGWREST::preprocess(), in
  // v17.2.6 it's in rgw_rest.cc near line 2152: If the domain name appears to
  // be a prefix on a name we recognise (e.g. bucket.host.name for a server
  // with name host.name), we prepend "bucket" to the list of parameters.
  //
  // This is super helpful as it means we don't have to handle the special
  // case.

  req = std::string(req_name);
  size_t pos = req.find('/');
  if (pos != std::string::npos) {
    bucket_name_ = req.substr(0, pos);
  } else {
    bucket_name_ = req;
  }

  // The object key name can legitimately be empty.
  if (pos != std::string::npos && req.size() > pos) {
    object_key_name_ = req.substr(pos + 1);
  }

  valid_ = true;
}

std::string EAKParameters::to_string() const noexcept
{
  if (valid()) {
    return fmt::format("EAKParameters(method={},bucket={},key={})", method(), bucket_name(), object_key_name());
  } else {
    return "EAKParameters(INVALID)";
  }
}

std::ostream& operator<<(std::ostream& os, const EAKParameters& ep)
{
  os << ep.to_string();
  return os;
}

} /* namespace rgw */
