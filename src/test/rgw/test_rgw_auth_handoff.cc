// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
// vim: ts=8 sw=2 smarttab

#include <cstdint>
#include <iostream>
#include <optional>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#include <absl/random/random.h>
#include <boost/algorithm/hex.hpp>
#include <boost/regex.hpp>
#include <fmt/format.h>
#include <gmock/gmock-matchers.h>
#include <grpc/grpc.h>
#include <grpcpp/channel.h>
#include <grpcpp/client_context.h>
#include <grpcpp/create_channel.h>
#include <gtest/gtest.h>
#include <openssl/evp.h>

#include "common/async/yield_context.h"
#include "common/ceph_argparse.h"
#include "common/ceph_json.h"
#include "common/dout.h"
#include "common/strtol.h"
#include "global/global_context.h"
#include "global/global_init.h"
#include "include/ceph_assert.h"
#include "rgw/rgw_b64.h"
#include "rgw/rgw_client_io.h"
#include "rgw/rgw_handoff.h"
#include "rgw/rgw_handoff_impl.h"
#include "rgw/rgw_http_client.h"

#include "test_rgw_grpc_util.h"

#include "rgw/auth/v1/auth.grpc.pb.h"

/*
 * Tools tests.
 */

namespace {

/* #region TestData */

// The information we need to use an access key.
struct AccessKeyInfo {
  std::string userid;
  std::string secret;
};

static std::unordered_map<std::string, AccessKeyInfo>
    super_secret_vault = {
      // This is the 'testid' user created by many tests, and installed by
      // default into dbstore.
      { "0555b35654ad1656d804", { "testid", "h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q==" } },
      { "AKIAIOSFODNN7EXAMPLE", { "awsquerystringexample", "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY" } }
    };

// Look up the userid and secret for a given credential (access key id).
static std::optional<AccessKeyInfo>
info_for_credential(const std::string& access_key)
{
  auto srch = super_secret_vault.find(access_key);
  if (srch == super_secret_vault.end()) {
    return std::nullopt;
  }
  return std::make_optional(srch->second);
}

struct HandoffHdrTestData {
  std::string name;
  /// @brief The string_to_sign field.
  std::string ss_base64;
  std::string access_key;
  std::string signature;
  std::string authorization;
};

static HandoffHdrTestData sigpass_tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature.
        {
            "s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "0555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature.
        {
            "dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `s3cmd ls s3://test` with nothing in the bucket.
        // V2 signature.
        {
            "s3cmd ls s3://test (empty -> v2 auth)",
            "R0VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
            "0555b35654ad1656d804",
            "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
            "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE=" }
      };

HandoffHdrTestData sigfail_tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature. stringToSign corrupted, but carefully
        // since it's base64 encoded - if we just randomly corrupt it, we
        // might get invalid utf-8 which upsets gRPC.
        {
            "xfail (access_key): s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNjgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMgo=",
            "1555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        }, // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature. access_key corrupted.
        {
            "xfail (access_key): s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "1555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature. Signature corrupted.
        {
            "xfail (sig): dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=1c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature. Authorization header corrupted.
        {
            "xfail (authhdr): dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/xs-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `s3cmd ls s3://test` with nothing in the bucket.
        // V2 signature. stringToSign corrupted.
        {
            "xfail (v2 access key): s3cmd ls s3://test (empty -> v2 auth)",
            "00VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
            "0555b35654ad1656d804",
            "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
            "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE=" }
      };

// This is generated by
//   `s3cmd ls s3://test` with nothing in the bucket.
// V2 signature.
HandoffHdrTestData v2_sample = {
  "v2_sample",
  "R0VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
  "0555b35654ad1656d804",
  "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
  "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE="
};

struct HandoffQueryTestData {
  std::string name;
  std::string access_key;
  std::string presignedUrl;
};

HandoffQueryTestData presigned_pass_tests[] = {
  { "'s3cmd signurl s3://testnv/rand +3600' at 1696590328",
      "0555b35654ad1656d804",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1696593928&Signature=2yvZEGjagY%2B5nyk9IcBOR%2Bu5KT8%3D" }
};

/* #endregion */
/* #region SupportCode */

namespace ba = boost::algorithm;

#define SSL_CHAR_CAST(x) reinterpret_cast<const unsigned char*>(x)

// Wrap the rigmarole of hashing a buffer with OpenSSL.
static std::optional<std::vector<uint8_t>> _hash_by(const std::vector<uint8_t>& key, const std::string& input, const std::string& hash_type)
{
  auto pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key.data(), key.size());
  auto md = EVP_get_digestbyname(hash_type.c_str());
  auto ctx = EVP_MD_CTX_new();
  if (!EVP_DigestSignInit(ctx, NULL, md, NULL, pkey)) {
    std::cerr << "HMAC ctx init failed" << std::endl;
    return std::nullopt;
  }
  if (!EVP_DigestSignUpdate(ctx, input.data(), input.size())) {
    std::cerr << "HMAC update failed" << std::endl;
    return std::nullopt;
  }
  std::vector<uint8_t> hash(EVP_MD_size(md));
  size_t hsiz = hash.size();
  if (!EVP_DigestSignFinal(ctx, hash.data(), &hsiz) || static_cast<int>(hsiz) != EVP_MD_size(md)) {
    std::cerr << "HMAC final failed" << std::endl;
    return std::nullopt;
  }
  EVP_MD_CTX_free(ctx);
  return std::make_optional(hash);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v4_auth { "^AWS4-HMAC-SHA256\\sCredential=(?<accesskey>[0-9a-f]+)/(?<date>\\d+)"
                                 "/(?<region>[0-9a-z-]+)"
                                 "/(?<service>[0-9a-z-]+)"
                                 "/aws4_request"
                                 ",SignedHeaders=(?<signhdr>[-;a-z0-9]+)"
                                 ",Signature=(?<sig>[0-9a-f]+)"
                                 "$" };

/* Given the inputs, generate an AWS v4 signature and return as an
 * optional<string>. In case of problems, return nullopt.
 *
 * This is the part the authenticator normally performs.
 */
static std::optional<std::string> verify_aws_v4_signature(std::string string_to_sign, std::string access_key_id, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'", string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v4_auth)) {
    std::cerr << "no match v4" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrdate = m.str("date");
  auto hdrregion = m.str("region");
  auto hdrservice = m.str("service");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto initstr = "AWS4" + secret_key;
  std::vector<uint8_t> init;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(initstr.begin(), initstr.end(), std::back_inserter(init));

  // Hash each step.
  auto datekey = _hash_by(init, hdrdate, "SHA256");
  if (!datekey) {
    return std::nullopt;
  }
  auto dateregionkey = _hash_by(*datekey, hdrregion, "SHA256");
  if (!dateregionkey) {
    return std::nullopt;
  }
  auto dateregionservicekey = _hash_by(*dateregionkey, hdrservice, "SHA256");
  if (!dateregionservicekey) {
    return std::nullopt;
  }
  auto signingkey = _hash_by(*dateregionservicekey, "aws4_request", "SHA256");
  if (!signingkey) {
    return std::nullopt;
  }

  // Step 3.
  auto sigbytes = _hash_by(*signingkey, string_to_sign, "SHA256");
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  boost::algorithm::hex_lower(*sigbytes, std::back_inserter(sigstr));

  // Compare the signature to that in the header.
  if (sigstr != hdrsig) {
    std::cerr << fmt::format("signature mismatch got='{}' expected='{}'", sigstr, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sigstr);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v2_auth { "^AWS\\s(?<accesskey>[0-9a-f]+):"
                                 "(?<sig>[^ \t]+)"
                                 "$" };

/* Given the inputs, generate an AWS v4 signature and return as an
 * optional<string>. In case of problems, return nullopt.
 *
 * This is the part the authenticator normally performs.
 */
static std::optional<std::string> verify_aws_v2_signature(std::string string_to_sign, std::string access_key_id, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'", string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v2_auth)) {
    std::cerr << "no match V2" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto initstr = secret_key;
  std::vector<uint8_t> signingkey;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(initstr.begin(), initstr.end(), std::back_inserter(signingkey));

  // Step 3.
  auto sigbytes = _hash_by(signingkey, string_to_sign, "SHA1");
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  std::copy((*sigbytes).begin(), (*sigbytes).end(), std::back_inserter(sigstr));
  auto sig_b64 = rgw::to_base64(sigstr);

  // Compare the signature to that in the header.
  if (sig_b64 != hdrsig) {
    std::cerr << fmt::format("signature mismatch got='{}' expected='{}'", sig_b64, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sig_b64);
}

// Examine the Authorization header. If it starts with 'AWS ', call the v2
// signature handler. Otherwise call the v4 handler.
static std::optional<std::string> verify_aws_signature(std::string string_to_sign, std::string access_key_id, std::string secret_key, std::string authorization)
{
  if (ba::starts_with(authorization, "AWS ")) {
    return verify_aws_v2_signature(string_to_sign, access_key_id, secret_key, authorization);
  } else {
    return verify_aws_v4_signature(string_to_sign, access_key_id, secret_key, authorization);
  }
}

// Stand in for the standard verify callout, which calls the authenticator
// using HTTP. Here, we'll unpack the request and call the signature
// implementation ourselves, package a JSON response and return it in the
// provided bufferlist.
//
// As the real function, we return our result struct appropriately filled, and
// on success we put the reply markup for the caller in the bufferlist.
static rgw::HandoffHTTPVerifyResult http_verify_by_func(const DoutPrefixProvider* dpp, const std::string& request_json, ceph::bufferlist* resp_bl, [[maybe_unused]] optional_yield y)
{

  JSONParser parser;
  if (!parser.parse(request_json.c_str(), request_json.size())) {
    std::cerr << "Unable to parse request JSON" << std::endl;
    return rgw::HandoffHTTPVerifyResult(-EACCES, 401);
  }

  std::string string_to_sign_base64;
  std::string access_key_id;
  std::string authorization;
  try {
    JSONDecoder::decode_json("stringToSign", string_to_sign_base64, &parser, true);
    JSONDecoder::decode_json("accessKeyId", access_key_id, &parser, true);
    JSONDecoder::decode_json("authorization", authorization, &parser, true);

  } catch (const JSONDecoder::err& err) {
    std::cerr << "request parse error: " << err.what() << std::endl;
    return rgw::HandoffHTTPVerifyResult(-EACCES, 401);
  }

  std::string string_to_sign = rgw::from_base64(string_to_sign_base64);

  auto info = info_for_credential(access_key_id);
  if (!info) {
    return rgw::HandoffHTTPVerifyResult(-EACCES, 404);
  }
  auto secret = (*info).secret;
  // std::cerr << fmt::format("verify_by_func(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'", string_to_sign, access_key_id, secret, authorization) << std::endl;

  auto gen_signature = verify_aws_signature(string_to_sign, access_key_id, secret, authorization);
  std::string message;
  if (gen_signature.has_value()) {
    message = "OK";
  } else {
    return rgw::HandoffHTTPVerifyResult(-EACCES, 401);
  }

  // We only need to create the response body if we're about to return
  // success.

  JSONFormatter jf { true };
  jf.open_object_section(""); // root
  encode_json("message", message, &jf);
  encode_json("uid", (*info).userid, &jf);
  jf.close_section(); // root
  std::ostringstream oss;
  jf.flush(oss);

  resp_bl->append(oss.str());

  return rgw::HandoffHTTPVerifyResult(0, 200);
}

// Minimal client for req_state.
class TestClient : public rgw::io::BasicClient {
  RGWEnv env;

protected:
  virtual int init_env(CephContext* cct) override
  {
    return 0;
  }

public:
  virtual RGWEnv& get_env() noexcept override
  {
    return env;
  }

  virtual size_t complete_request() override
  {
    return 0;
  }
};

/* #endregion */

using namespace rgw;

/*
 * File-local framework tests.
 */

// Test the local signature implementation with known-good signature data.
TEST(HandoffMeta, SigPositive)
{
  for (const auto& t : sigpass_tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto s2s = rgw::from_base64(t.ss_base64);
    auto sig = verify_aws_signature(s2s, t.access_key, (*info).secret, t.authorization);
    ASSERT_TRUE(sig);
  }
}

TEST(HandoffMeta, SigNegative)
{
  for (const auto& t : sigpass_tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto s2s = rgw::from_base64(t.ss_base64);
    auto sig = verify_aws_signature("0" + s2s, t.access_key, (*info).secret, t.authorization);
    ASSERT_FALSE(sig);
    sig = verify_aws_signature(t.ss_base64, t.access_key, (*info).secret + "0", t.authorization);
    ASSERT_FALSE(sig);
  }
}

/*
 * HandoffHelper tests.
 */

TEST(HandoffHelper, Init)
{
  HandoffHelper hh;
  ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
}

/* #region HandoffHelperImplHTTP tests */

/**
 * @brief HTTP-mode HandoffHelperImpl end-to-end test fixture.
 *
 * Not using a parameterised test for HTTP and gRPC because I anticipate
 * removing the HTTP mode at some point, and it will be a pain to unpick.
 * Plus, the test harnesses for HTTP and gRPC are quite different.
 */
class HandoffHelperImplHTTPTest : public ::testing::Test {
protected:
  void SetUp() override
  {
    dpp.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "false");
    dpp.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp.get_cct()->_conf->rgw_handoff_enable_grpc, false);
    ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
  }

  HandoffHelperImpl hh { http_verify_by_func };
  optional_yield y = null_yield;
  DoutPrefix dpp { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

// Fail properly when the Authorization header is absent and one can't be
// synthesized.
TEST_F(HandoffHelperImplHTTPTest, FailIfMissingAuthorizationHeader)
{
  TestClient cio;

  auto t = sigpass_tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("missing Authorization"));
}

TEST_F(HandoffHelperImplHTTPTest, SignatureV2CanBeDisabled)
{
  // // XXX I can't get the configuration observer to work in the harness.
  // // Luckily there are methods on the helperimpl that I can call directly.

  auto t = v2_sample;

  TestClient cio;
  // Set headers in the cio's env, not rgw_env (below).
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  ldpp_dout(&dpp, 20) << fmt::format("Auth: {}", t.authorization) << dendl;

  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  // This is what the config observer would call.
  hh.set_signature_v2(dpp.get_cct(), true);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_TRUE(res.is_ok());

  // dpp.get_cct()->_conf->rgw_handoff_enable_signature_v2 = false;
  // dpp.get_cct()->_conf.apply_changes(nullptr);
  hh.set_signature_v2(dpp.get_cct(), false);
  res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_TRUE(res.is_err());

  // dpp.get_cct()->_conf->rgw_handoff_enable_signature_v2 = true;
  // dpp.get_cct()->_conf.apply_changes(nullptr);
  hh.set_signature_v2(dpp.get_cct(), true);
  res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_TRUE(res.is_ok());
}

// Test working signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplHTTPTest, HeaderHappyPath)
{
  for (const auto& t : sigpass_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp, 20) << fmt::format("Auth: {}", t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
    ASSERT_TRUE(res.is_ok()) << "should pass test '" << t.name << "'";
  }
}

// Test deliberately broken signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplHTTPTest, HeaderExpectBadSignature)
{
  for (const auto& t : sigfail_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp, 20) << fmt::format("Auth: {}", t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
    ASSERT_FALSE(res.is_ok()) << "should fail test '" << t.name << "'";
  }
}

/* #endregion HandoffHelperImplHTTP tests */

/* #region HandoffHelperImplGRPC tests */

class TestAuthImpl final : public rgw::auth::v1::AuthService::Service {

  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest gRPC server " };

  // This is AuthService's ping equivalent.
  grpc::Status Status(grpc::ServerContext* context, const rgw::auth::v1::StatusRequest* request, rgw::auth::v1::StatusResponse* response) override
  {
    response->set_server_description("TestAuthImpl");
    return grpc::Status::OK;
  }

  // Very simple implementation of the auth service. XXX Isn't as careful with
  // return codes as it could be, and returns no authorization-related codes.
  grpc::Status Auth(grpc::ServerContext* context, const rgw::auth::v1::AuthRequest* request, rgw::auth::v1::AuthResponse* response) override
  {
    ldpp_dout(&dpp_, 20) << __func__ << ": enter" << dendl;

    // Use our pre-canned authentication database.
    auto info = info_for_credential(request->access_key_id());
    if (!info) {
      ldpp_dout(&dpp_, 20) << __func__ << ": exit CREDENTIALS NOT FOUND" << dendl;
      response->set_message("CREDENTIALS NOT FOUND");
      response->set_code(rgw::auth::v1::AUTH_CODE_UNAUTHORIZED);
      return grpc::Status::OK;
    }
    auto sig = verify_aws_signature(request->string_to_sign(),
        request->access_key_id(),
        info->secret,
        request->authorization_header());
    if (!sig) {
      ldpp_dout(&dpp_, 20) << __func__ << ": exit SIGNATURE MISMATCH" << dendl;
      response->set_message("SIGNATURE NOT VERIFIED");
      response->set_code(rgw::auth::v1::AUTH_CODE_UNAUTHORIZED);
      return grpc::Status::OK;
    }
    response->set_message("OK");
    response->set_uid(info->userid);
    response->set_code(rgw::auth::v1::AUTH_CODE_OK);
    ldpp_dout(&dpp_, 20) << __func__ << ": exit OK" << dendl;
    return grpc::Status::OK;
  }
};

/**
 * @brief gRPC mode HandoffHelperImpl end-to-end test fixture.
 *
 * Not using a parameterised test for HTTP and gRPC because I anticipate
 * removing the HTTP mode at some point, and it will be a pain to unpick
 * later. Also, the harness classes are very different and it will become
 * spaghettified if I try to combine them.
 *
 * However: As long as both HTTP and gRPC are in the codebase there is some
 * duplication here in the tests themselves. At least they can reuse the test
 * vectors.
 *
 * Use GRPCTestServer to implement the gRPC server on a random port, then
 * configure the HandoffHelperImpl to use it. The tests then issue gRPC()
 * calls against the helper.
 *
 * You *MUST* call helper_init() if you're going to use the HandoffHelperImpl
 * at all! Otherwise the channel and store won't be set up. This isn't called
 * automatically because sometimes we want to modify the channel configuration
 * first.
 *
 * It also doesn't implicitly start the server, you have to call start_test().
 * This is so we can easily test behaviour when the server isn't started.
 *
 * This actual-server approach has the virtue of being a somewhat faithful
 * client-side test. The server side is rather simplistic, obviously; but
 * that's probably ok.
 *
 * The fixture _will_ call server().stop() in TearDown, that feels relatively
 * safe.
 */
class HandoffHelperImplGRPCTest : public ::testing::Test {

protected:
  HandoffHelperImpl hh_;
  optional_yield y_ = null_yield;
  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest " };

  // This manages the test gRPC server.
  GRPCTestServer<TestAuthImpl> server_;

  // Don't start the server - some tests might want a chance to see what
  // happens without a server.
  void SetUp() override
  {
  }

  void helper_init()
  {
    dpp_.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "true");
    dpp_.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp_.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    // Note init() can take the server address URI, it's normally defaulted to
    // empty which means 'use the Ceph configuration'.
    ASSERT_EQ(hh_.init(g_ceph_context, nullptr, server_.address()), 0);
  }

  // Will stop the server. There's no situation where we want it left around.
  void TearDown() override
  {
    server().stop();
  }

  /// Return the gRPC server manager instance.
  GRPCTestServer<TestAuthImpl>& server() { return server_; }
};

// This just tests we can instantiate the test classes.
TEST_F(HandoffHelperImplGRPCTest, Null)
{
}

// Make sure server().start() is idempotent.
TEST_F(HandoffHelperImplGRPCTest, MetaStart)
{
  server().start();
  for (int n = 0; n < 1000; n++) {
    server().start();
  }
  server().stop();
}

// Make sure server().stop() is idempotent.
TEST_F(HandoffHelperImplGRPCTest, MetaStop)
{
  server().start();
  for (int n = 0; n < 1000; n++) {
    server().stop();
  }
}

// Status() is essentially a ping.
TEST_F(HandoffHelperImplGRPCTest, StatusWorksWithServer)
{
  server().start();
  helper_init();
  auto channel = grpc::CreateChannel(server().address(), grpc::InsecureChannelCredentials());
  AuthServiceClient client { channel };
  StatusRequest req;
  auto desc = client.Status(req);
  ASSERT_TRUE(desc.has_value()) << "Status() RPC failed";
  ASSERT_EQ(*desc, "TestAuthImpl");
}

TEST_F(HandoffHelperImplGRPCTest, StatusFailsWithoutServer)
{
  helper_init();
  auto channel = grpc::CreateChannel(server().address(), grpc::InsecureChannelCredentials());
  AuthServiceClient client { channel };
  StatusRequest req;
  auto desc = client.Status(req);
  ASSERT_FALSE(desc.has_value()) << "Status() RPC succeeded when it should have failed";
}

// Fail properly when the Authorization header is absent and one can't be
// synthesized.
TEST_F(HandoffHelperImplGRPCTest, FailIfMissingAuthorizationHeader)
{
  helper_init();
  TestClient cio;

  auto t = sigpass_tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("missing Authorization"));
}

TEST_F(HandoffHelperImplGRPCTest, SignatureV2CanBeDisabled)
{
  // // XXX I can't get the configuration observer to work in the harness.
  // // Luckily there are methods on the helperimpl that I can call directly.

  server().start();
  helper_init();

  auto t = v2_sample;

  TestClient cio;
  // Set headers in the cio's env, not rgw_env (below).
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  ldpp_dout(&dpp_, 20) << fmt::format("Auth: {}", t.authorization) << dendl;

  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  // This is what the config observer would call.
  hh_.set_signature_v2(dpp_.get_cct(), true);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok());

  // dpp_.get_cct()->_conf->rgw_handoff_enable_signature_v2 = false;
  // dpp_.get_cct()->_conf.apply_changes(nullptr);
  hh_.set_signature_v2(dpp_.get_cct(), false);
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_err());

  // dpp_.get_cct()->_conf->rgw_handoff_enable_signature_v2 = true;
  // dpp_.get_cct()->_conf.apply_changes(nullptr);
  hh_.set_signature_v2(dpp_.get_cct(), true);
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok());
}

// Test working signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplGRPCTest, HeaderHappyPath)
{
  server().start();
  helper_init();

  for (const auto& t : sigpass_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp_, 20) << fmt::format("Auth: {}", t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
    EXPECT_TRUE(res.is_ok()) << "should pass test '" << t.name << "'";
  }
}

// Test deliberately broken signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplGRPCTest, HeaderExpectBadSignature)
{
  server().start();
  helper_init();

  for (const auto& t : sigfail_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp_, 20) << fmt::format("Auth: {}", t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
    EXPECT_FALSE(res.is_ok()) << "should fail test '" << t.name << "'";
  }
}

// This is hardcoded in the library, you can't configure a reconnect delay
// less than 100ms. (grpc src/core/ext/filters/client_channel/subchannel.cc
// function ParseArgsForBackoffValues().) This allows five more milliseconds.
//
constexpr int SMALLEST_RECONNECT_DELAY_MS = 105;

// Check the system doesn't fail if started with a non-functional auth server.
TEST_F(HandoffHelperImplGRPCTest, ChannelRecoversFromDeadAtStartup)
{
  ceph_assert(g_ceph_context != nullptr);
  // Set everything to 1ms. As descrived for SMALLEST_RECONNECT_DELAY_MS,
  // we'll still have to wait 100ms + a few more millis for any reconnect.
  auto args = hh_.get_default_channel_args(g_ceph_context);
  args.SetInt(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1);
  args.SetInt(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 1);
  args.SetInt(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1);
  // // This is an alternate means of setting the reconnect delay, but it too
  // // bounded below at 100ms by the library.
  // args.SetInt("grpc.testing.fixed_fixed_reconnect_backoff_ms", 0);
  // Program the helper's channel.
  hh_.set_channel_args(dpp_.get_cct(), args);

  helper_init();
  TestClient cio;

  auto t = sigpass_tests[0];
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  ASSERT_FALSE(res.is_ok()) << "should fail";
  ASSERT_EQ(res.code(), -EACCES) << "should return -EACCES";
  ASSERT_EQ(res.err_type(), HandoffAuthResult::error_type::TRANSPORT_ERROR) << "should return TRANSPORT_ERROR";

  server().start();
  // Wait as short a time as the library allows.
  std::this_thread::sleep_for(std::chrono::milliseconds(SMALLEST_RECONNECT_DELAY_MS));
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok()) << "should now succeed";
  EXPECT_EQ(res.err_type(), HandoffAuthResult::error_type::NO_ERROR) << "should now show no error";
}

/* #endregion HandoffHelperImplGRPC tests */

/* #region PresignedTestData */

struct HandoffHeaderSynthData {
  std::string name;
  std::string url;
  std::string header;
};

static HandoffHeaderSynthData synth_pass[] = {
  // All use credential 0555b35654ad1656d804, the RGW test user.

  // `aws --endpoint-url='http://amygdala-ub01.home.ae-35.com:8000' s3 presign
  // s3://testnv/rand --expires 3600`. No region.
  {
      "aws s3 GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=XukLh8ZYkh7LhfDNGGPEznT5qMk%3D&Expires=1697103292",
      "AWS 0555b35654ad1656d804:XukLh8ZYkh7LhfDNGGPEznT5qMk=",
  },
  // `aws --endpoint-url='http://amygdala-ub01.home.ae-35.com:8000' s3 presign
  // s3://testnv/rand --expires 3600 --region eu-west-2`. Non-default region.
  {
      "aws s3 GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T083736Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d63f2167860f1f3a02b098988cbe9e7cf19e2d3208044e70d52bcc88985abb17",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=d63f2167860f1f3a02b098988cbe9e7cf19e2d3208044e70d52bcc88985abb17",
  },
  // `s3cmd --host http://amygdala-ub01.home.ae-35.com:8000 signurl
  // s3://testnv/rand +3600`. No region. No --host-bucket set.
  {
      "s3cmd signurl GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697103824&Signature=2X2H46QEM73dL8EAHiWTgpEUYqs%3D",
      "AWS 0555b35654ad1656d804:2X2H46QEM73dL8EAHiWTgpEUYqs=",
  },
  // `s3cmd --host http://amygdala-ub01.home.ae-35.com:8000 --region eu-west-2
  // signurl s3://testnv/rand +3600`. Non-default region. No --host-bucket
  // set. Note s3cmd didn't switch to the 'v4-ish' presigned URL format.
  {
      "s3cmd signurl GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697110701&Signature=1QoTXjLEU3oh0LTfRn5wrccgWWw%3D",
      "AWS 0555b35654ad1656d804:1QoTXjLEU3oh0LTfRn5wrccgWWw=" },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000 testnv rand get --expiry 3600`. No region.
  {
      "presigned_url.py GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=EqiVBEaa%2B9wUIpHUw26ph74Pq4o%3D&Expires=1697110900",
      "AWS 0555b35654ad1656d804:EqiVBEaa+9wUIpHUw26ph74Pq4o=",
  },

  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand get --expiry 3600 --region eu-west-2`. Non-default region.
  {
      "presigned_url.py GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T104359Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a54b4ae7a782c395ef8a75a0fbaf23f6d4a8e6d52d06cdc358be03344dd439b4",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=a54b4ae7a782c395ef8a75a0fbaf23f6d4a8e6d52d06cdc358be03344dd439b4",
  },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand put --expiry 3600`. No region.
  {
      "presigned_url.py PUT no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=ob%2FzEMUCnhQyX1KE6vhGo0oSZq4%3D&Expires=1697107623",
      "AWS 0555b35654ad1656d804:ob/zEMUCnhQyX1KE6vhGo0oSZq4=",
  },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand put --expiry 3600 --region eu-west-2`. Non-default region.
  {
      "presigned_url.py PUT with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T094852Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd8ed8099f8349c43bf1804bf3780ab0885e7c94baffcce65aacd34b4e6b6ade",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=cd8ed8099f8349c43bf1804bf3780ab0885e7c94baffcce65aacd34b4e6b6ade",
  }
};

/* #endregion */

/**
 * @brief HandoffHelperImpl test fixture. Not for end-to-end tests!
 */
class HandoffHelperImplSubsysTest : public ::testing::Test {
protected:
  void SetUp() override
  {
    // dpp.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "false");
    // dpp.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
  }

  static rgw::HandoffHTTPVerifyResult verify_throw(const DoutPrefixProvider* dpp, const std::string& request_json, ceph::bufferlist* resp_bl, [[maybe_unused]] optional_yield y)
  {
    throw new std::runtime_error("Should not get here");
  }

  bool grpc_enabled;
  HandoffHelperImpl hh { verify_throw };
  optional_yield y = null_yield;
  DoutPrefix dpp { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

// Make sure we're properly creating the Authorization: header from query
// parameters. This is order-dependent; however every program I've tried it
// with (s3cmd, aws s3 presign, the AWS presigned_url.py SDK example code)
// respects this order.
TEST_F(HandoffHelperImplSubsysTest, PresignedSynthesizeHeader)
{
  for (auto const& t : synth_pass) {

    // We need a req_state struct to pass to synthesize_auth_header(), so
    // implement the pieces of RGWHandler_REST_S3::init_from_header() that we
    // care about, taking the test URL as input.
    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    // In the input URL, skip to the '?' marking the start of URL parameters.
    // (This is what init_from_header() does.)
    auto p = t.url.c_str();
    for (auto c : t.url) {
      if (c == '?') {
        break;
      }
      p++;
    }
    ASSERT_TRUE(*p != 0) << t.name;
    // Parse arguments from the URL.
    s.info.args.set(p);
    s.info.args.parse(&s);
    // End init_from_header() mock.

    auto got = hh.synthesize_auth_header(&dpp, &s);
    ASSERT_TRUE(got.has_value()) << t.name;
    EXPECT_EQ(*got, t.header) << t.name;
  }
}

/* #region PresignedExpiryData */

struct PresignedExpiryData {
  std::string name;
  std::string url;
  time_t now;
  time_t delta;
};

static PresignedExpiryData expiry_unit[] = {
  {
      // Basic GET, v2 syntax (no region).
      // `s3cmd --host http://amygdala.home.ae-35.com:8000 signurl s3://testnv/rand +60`
      "s3cmd signurl +60",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697122817&Signature=2HxhmxDYl0WgfktL0L62GVC%2B9vY%3D",
      1697122757,
      60,
  },
  {
      // Basic GET, v4 syntax (region).
      // `aws --endpoint-url=http://amygdala.home.ae-35.com:8000 s3 presign
      // s3://testnv/rand --expires 60 --region eu-west-2`
      "aws s3 presign +60 region",
      "http://amygdala.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T153745Z&X-Amz-Expires=60&X-Amz-SignedHeaders=host&X-Amz-Signature=050fcdc4e6f7046776b36a869ad428c68ffb7dbba807af18f146ca3923b21e2f",
      1697125065,
      60,
  }
};

/* #endregion */

// Presigned headers have an expiry time. If we're past that time, we
// shouldn't even pass the request to the Authenticator.
TEST_F(HandoffHelperImplSubsysTest, PresignedCheckExpiry)
{
  for (auto const& t : expiry_unit) {

    // We need a req_state struct to pass to synthesize_auth_header(), so
    // implement the pieces of RGWHandler_REST_S3::init_from_header() that we
    // care about, taking the test URL as input.
    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    // In the input URL, skip to the '?' marking the start of URL parameters.
    // (This is what init_from_header() does.)
    auto p = t.url.c_str();
    for (auto c : t.url) {
      if (c == '?') {
        break;
      }
      p++;
    }
    ASSERT_TRUE(*p != 0) << t.name;
    // Parse arguments from the URL.
    s.info.args.set(p);
    s.info.args.parse(&s);
    // End init_from_header() mock.

    auto actual = hh.valid_presigned_time(&dpp, &s, t.now);
    EXPECT_EQ(actual, true) << t.name << ": expect pass (t==now)";
    actual = hh.valid_presigned_time(&dpp, &s, t.now + t.delta);
    EXPECT_EQ(actual, true) << t.name << ": expect pass (t==now+delta)";
    actual = hh.valid_presigned_time(&dpp, &s, t.now + t.delta + 1);
    EXPECT_EQ(actual, false) << t.name << ": expect fail (t==now+delta+1)";
  }
}

/* #region AuthorizationParametersTestData */

struct AuthorizationConstructTest {
  std::string method;
  // Note that the r_uri is used as s->relative_uri. We don't have to worry
  // about URL encoding of the bucket and keys. Why? In
  // RGWREST::get_handler(), we do RGWREST::preprocess() which fills in
  // s->decoded_uri, and immediately s->decoded_uri is used to initialise the
  // RGWRestMgr, whose out parameter is s->relative_uri.
  //
  std::string r_uri;
  bool expected_pass;
  std::string exp_method;
  std::string exp_bucket;
  std::string exp_object_key;
};

static AuthorizationConstructTest eak_unit[] = {
  // Simple get.
  { "GET", "/bucket/key", true, "GET", "bucket", "key" },
  // Simple put.
  { "PUT", "/bucket/key", true, "PUT", "bucket", "key" },
  // Get with non-ASCII7 key. Essentially a no-op because we get the URL
  // post-decoding.
  { "GET", "/foo/Déjà vu", true, "GET", "foo", "Déjà vu" },
  // Get for ls (i.e. no key).
  { "GET", "/bucket", true, "GET", "bucket", "" },
  // Broken: No method.
  { "", "/bucket", false, "", "", "" },
  // Broken: No bucket or key.
  { "GET", "/", true, "GET", "", "" },
};

/* #endregion */

TEST_F(HandoffHelperImplSubsysTest, AuthorizationParamConstruct)
{
  for (const auto& t : eak_unit) {
    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };

    TestClient cio;
    // Set a header that should be included in the params.
    cio.get_env().set("HTTP_FOO", "bar");
    s.cio = &cio;

    auto test_desc = fmt::format("for test: {} {} exp:{}", t.method, t.r_uri, t.expected_pass);
    s.info.method = t.method.c_str();
    s.relative_uri = t.r_uri;

    auto param = rgw::AuthorizationParameters(&dpp, &s);

    if (!t.expected_pass) {
      EXPECT_FALSE(param.valid()) << test_desc;
      EXPECT_ANY_THROW(param.method()) << test_desc;
      EXPECT_ANY_THROW(param.bucket_name()) << test_desc;
      EXPECT_ANY_THROW(param.object_key_name()) << test_desc;
    } else {
      ASSERT_TRUE(param.valid()) << test_desc;
      EXPECT_EQ(param.method(), t.exp_method) << test_desc;
      EXPECT_EQ(param.bucket_name(), t.exp_bucket) << test_desc;
      EXPECT_EQ(param.object_key_name(), t.exp_object_key) << test_desc;
      // Any valid request should have the headers.
      ASSERT_NE(param.http_headers().find("foo"), param.http_headers().end()) << test_desc;
      EXPECT_EQ(param.http_headers().at("foo"), "bar") << test_desc;
    }
  }
}

} // namespace rgw

// main() cribbed from test_http_manager.cc

int main(int argc, char** argv)
{
  auto args = argv_to_vec(argc, argv);
  auto cct = global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT, CODE_ENVIRONMENT_UTILITY, CINIT_FLAG_NO_DEFAULT_CONFIG_FILE);
  common_init_finish(g_ceph_context);

  // These can most likely go when HTTP mode is removed.
  rgw_http_client_init(cct->get());
  rgw_setup_saved_curl_handles();

  // Let the caller change the library debug level.
  if (std::getenv("TEST_DEBUG")) {
    std::string err;
    int level = strict_strtol(std::getenv("TEST_DEBUG"), 10, &err);
    if (err.empty()) {
      g_ceph_context->_conf->subsys.set_log_level(ceph_subsys_rgw, std::min(level, 30));
    }
  }

  ::testing::InitGoogleTest(&argc, argv);
  int r = RUN_ALL_TESTS();

  // These can most likely go when HTTP mode is removed.
  rgw_release_all_curl_handles();
  rgw_http_client_cleanup();

  return r;
}
