// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
// vim: ts=8 sw=2 smarttab

#include "common/async/yield_context.h"
#include "common/ceph_argparse.h"
#include "common/ceph_json.h"
#include "global/global_init.h"
#include "rgw/rgw_b64.h"
#include "rgw/rgw_client_io.h"
#include "rgw/rgw_handoff.h"
#include "rgw/rgw_http_client.h"
#include <boost/algorithm/hex.hpp>
#include <boost/regex.hpp>
#include <cstdint>
#include <fmt/format.h>
#include <gmock/gmock-matchers.h>
#include <gtest/gtest.h>
#include <iostream>
#include <openssl/evp.h>
#include <optional>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

/*
 * Tools tests.
 */

namespace {

// The information we need to use an access key.
struct AccessKeyInfo {
  std::string userid;
  std::string secret;
};

static std::unordered_map<std::string, AccessKeyInfo>
    super_secret_vault = {
      // This is the 'testid' user created by many tests, and installed by
      // default into dbstore.
      { "0555b35654ad1656d804", { "testid", "h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q==" } }
    };

// Look up the userid and secret for a given credential (access key id).
static std::optional<AccessKeyInfo>
info_for_credential(const std::string& access_key)
{
  auto srch = super_secret_vault.find(access_key);
  if (srch == super_secret_vault.end()) {
    return std::nullopt;
  }
  return std::make_optional(srch->second);
}

struct HandoffTestData {
  /// @brief The string_to_sign field.
  std::string ss_base64;
  std::string access_key;
  std::string signature;
  std::string authorization;
};

HandoffTestData tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature.
        {
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "0555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature.
        { "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" }

      };

#define SSL_CHAR_CAST(x) reinterpret_cast<const unsigned char*>(x)

static constexpr unsigned int SHA256_HASH_SIZE_BYTES = 32;

// Wrap the rigmarole of hashing a buffer with OpenSSL.
static std::optional<std::vector<uint8_t>> _hash(const std::vector<uint8_t>& key, std::string input)
{
  auto pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key.data(), key.size());
  auto md = EVP_get_digestbyname("SHA256");
  auto ctx = EVP_MD_CTX_new();
  if (!EVP_DigestSignInit(ctx, NULL, md, NULL, pkey)) {
    std::cerr << "HMAC ctx init failed" << std::endl;
    return std::nullopt;
  }
  if (!EVP_DigestSignUpdate(ctx, input.data(), input.size())) {
    std::cerr << "HMAC update failed" << std::endl;
    return std::nullopt;
  }
  std::vector<uint8_t> hash(SHA256_HASH_SIZE_BYTES);
  size_t hsiz = hash.size();
  if (!EVP_DigestSignFinal(ctx, hash.data(), &hsiz) || hsiz != SHA256_HASH_SIZE_BYTES) {
    std::cerr << "HMAC final failed" << std::endl;
    return std::nullopt;
  }
  EVP_MD_CTX_free(ctx);
  return std::make_optional(hash);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v4_auth { "^AWS4-HMAC-SHA256\\sCredential=(?<accesskey>[0-9a-f]+)/(?<date>\\d+)"
                                 "/(?<region>[0-9a-z-]+)"
                                 "/(?<service>[0-9a-z-]+)"
                                 "/aws4_request"
                                 ",SignedHeaders=(?<signhdr>[-;a-z0-9]+)"
                                 ",Signature=(?<sig>[0-9a-f]+)"
                                 "$" };

/* Given the inputs, generate an AWS v4 signature and return as an
 * optional<string>. In case of problems, return nullopt.
 *
 * This is the part the authenticator normally performs. Note string_to_sign
 * will be base64 encoded, as this is the way it's passed to the authenticator
 * backend by HandoffHelper.
 */
static std::optional<std::string> verify_aws_v4_signature(std::string string_to_sign, std::string access_key_id, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'", string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v4_auth)) {
    std::cerr << "no match" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrdate = m.str("date");
  auto hdrregion = m.str("region");
  auto hdrservice = m.str("service");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto initstr = "AWS4" + secret_key;
  std::vector<uint8_t> init;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(initstr.begin(), initstr.end(), std::back_inserter(init));

  // Hash each step.
  auto datekey = _hash(init, hdrdate);
  if (!datekey) {
    return std::nullopt;
  }
  auto dateregionkey = _hash(*datekey, hdrregion);
  if (!dateregionkey) {
    return std::nullopt;
  }
  auto dateregionservicekey = _hash(*dateregionkey, hdrservice);
  if (!dateregionservicekey) {
    return std::nullopt;
  }
  auto signingkey = _hash(*dateregionservicekey, "aws4_request");
  if (!signingkey) {
    return std::nullopt;
  }

  // Step 3.
  auto s2s = rgw::from_base64(string_to_sign);
  auto sigbytes = _hash(*signingkey, s2s);
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  boost::algorithm::hex_lower(*sigbytes, std::back_inserter(sigstr));

  // Compare the signature to that in the header.
  if (sigstr != hdrsig) {
    std::cerr << fmt::format("signature mismatch got='{}' expected='{}'", sigstr, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sigstr);
}

// Stand in for the standard verify callout, which calls the authenticator
// using HTTP. Here, we'll unpack the request and call the signature
// implementation ourselves, package a JSON response and return it in the
// provided bufferlist.
//
// XXX It's a little ugly to have both the return struct and the bufferlist.
static rgw::HandoffVerifyResult verify_by_func(const DoutPrefixProvider* dpp, const std::string& request_json, ceph::bufferlist* resp_bl, [[maybe_unused]] optional_yield y)
{

  JSONParser parser;
  if (!parser.parse(request_json.c_str(), request_json.size())) {
    std::cerr << "Unable to parse request JSON" << std::endl;
    return rgw::HandoffVerifyResult(-EACCES, 401);
  }

  std::string string_to_sign;
  std::string access_key_id;
  std::string authorization;
  try {
    JSONDecoder::decode_json("stringToSign", string_to_sign, &parser, true);
    JSONDecoder::decode_json("accessKeyId", access_key_id, &parser, true);
    JSONDecoder::decode_json("authorization", authorization, &parser, true);

  } catch (const JSONDecoder::err& err) {
    std::cerr << "request parse error: " << err.what() << std::endl;
    return rgw::HandoffVerifyResult(-EACCES, 401);
  }

  auto info = info_for_credential(access_key_id);
  if (!info) {
    return rgw::HandoffVerifyResult(-EACCES, 404);
  }
  auto secret = (*info).secret;
  // std::cerr << fmt::format("verify_by_func(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'", string_to_sign, access_key_id, secret, authorization) << std::endl;

  auto signature = verify_aws_v4_signature(string_to_sign, access_key_id, secret, authorization);

  std::string message;
  if (signature) {
    message = "OK";
  } else {
    return rgw::HandoffVerifyResult(-EACCES, 401);
  }

  JSONFormatter jf { true };
  jf.open_object_section(""); // root
  encode_json("message", message, &jf);
  encode_json("uid", (*info).userid, &jf);
  jf.close_section(); // root
  std::ostringstream oss;
  jf.flush(oss);

  resp_bl->append(oss.str());

  return rgw::HandoffVerifyResult(0, 200);
}

// Minimal client for req_state.
class TestClient : public rgw::io::BasicClient {
  RGWEnv env;

protected:
  virtual int init_env(CephContext* cct) override
  {
    return 0;
  }

public:
  virtual RGWEnv& get_env() noexcept override
  {
    return env;
  }

  virtual size_t complete_request() override
  {
    return 0;
  }
};

} // namespace

using namespace rgw;

/*
 * File-local framework tests.
 */

// Test the local signature implementation with known-good signature data.
TEST(HandoffMeta, Sig)
{
  for (const auto& t : tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto sig = verify_aws_v4_signature(t.ss_base64, t.access_key, (*info).secret, t.authorization);
    ASSERT_TRUE(sig);
  }
}

/*
 * HandoffHelper tests.
 */

TEST(HandoffHelper, Init)
{
  HandoffHelper hh;
  ASSERT_EQ(hh.init(g_ceph_context), 0);
}

// Don't deref if cct->cio == nullptr.
TEST(HandoffHelper, RegressNullCioPtr)
{
  HandoffHelper hh { verify_by_func };
  ASSERT_EQ(hh.init(g_ceph_context), 0);

  optional_yield y = null_yield;
  NoDoutPrefix dpp(g_ceph_context, 1);

  auto t = tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("cio"));
}

// Fail properly when the Authorization header is absent.
TEST(HandoffHelper, FailIfMissingAuthorizationHeader)
{
  HandoffHelper hh { verify_by_func };
  ASSERT_EQ(hh.init(g_ceph_context), 0);

  optional_yield y = null_yield;
  NoDoutPrefix dpp(g_ceph_context, 1);

  TestClient cio;

  auto t = tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("missing Authorization"));
}

// Fail properly when we see a v2 signature.
// XXX we should support V2 signatures.
TEST(HandoffHelper, FailIfAWSV2SignatureSeen)
{
  HandoffHelper hh { verify_by_func };
  ASSERT_EQ(hh.init(g_ceph_context), 0);

  optional_yield y = null_yield;
  NoDoutPrefix dpp(g_ceph_context, 1);

  TestClient cio;
  // Set headers in the cio's env, not rgw_env (below).
  cio.get_env().set("HTTP_AUTHORIZATION", "AWS blah");

  auto t = tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("V2"));
}

// Test working signatures with the verify_by_func handler above.
TEST(HandoffHelper, HappyPath)
{
  HandoffHelper hh { verify_by_func };
  ASSERT_EQ(hh.init(g_ceph_context), 0);

  optional_yield y = null_yield;
  NoDoutPrefix dpp(g_ceph_context, 1);

  for (const auto& t : tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
    ASSERT_TRUE(res.is_ok());
  }
}

// main() cribbed from test_http_manager.cc

int main(int argc, char** argv)
{
  auto args = argv_to_vec(argc, argv);
  auto cct = global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT, CODE_ENVIRONMENT_UTILITY, CINIT_FLAG_NO_DEFAULT_CONFIG_FILE);
  common_init_finish(g_ceph_context);

  rgw_http_client_init(cct->get());
  rgw_setup_saved_curl_handles();
  ::testing::InitGoogleTest(&argc, argv);
  int r = RUN_ALL_TESTS();
  rgw_release_all_curl_handles();
  rgw_http_client_cleanup();
  return r;
}
